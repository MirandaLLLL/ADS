

/*
When the input is much too large to fit into memory, we have to do external sorting instead of internal sorting. One of the key steps in external sorting is to generate sets of sorted records (also called runs) with limited internal memory. The simplest method is to read as many records as possible into the memory, and sort them internally, then write the resulting run back to some tape. The size of each run is the same as the capacity of the internal memory.

Replacement Selection sorting algorithm was described in 1965 by Donald Knuth. Notice that as soon as the first record is written to an output tape, the memory it used becomes available for another record. Assume that we are sorting in ascending order, if the next record is not smaller than the record we have just output, then it can be included in the run.

For example, suppose that we have a set of input { 81, 94, 11, 96, 12, 99, 35 }, and our memory can sort 3 records only. By the simplest method we will obtain three runs: { 11, 81, 94 }, { 12, 96, 99 } and { 35 }. According to the replacement selection algorithm, we would read and sort the first 3 records { 81, 94, 11 } and output 11 as the smallest one. Then one space is available so 96 is read in and will join the first run since it is larger than 11. Now we have { 81, 94, 96 }. After 81 is out, 12 comes in but it must belong to the next run since it is smaller than 81. Hence we have { 94, 96, 12 } where 12 will stay since it belongs to the next run. When 94 is out and 99 is in, since 99 is larger than 94, it must belong to the first run. Eventually we will obtain two runs: the first one contains { 11, 81, 94, 96, 99 } and the second one contains { 12, 35 }.

Your job is to implement this replacement selection algorithm.

Input Specification:
Each input file contains several test cases. The first line gives two positive integers N (≤10 
5
 ) and M (<N/2), which are the total number of records to be sorted, and the capacity of the internal memory. Then N numbers are given in the next line, all in the range of int. All the numbers in a line are separated by a space.

Output Specification:
For each test case, print in each line a run (in ascending order) generated by the replacement selection algorithm. All the numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.

Sample Input:
13 3
81 94 11 96 12 99 17 35 28 58 41 75 15
Sample Output:
11 81 94 96 99
12 17 28 35 41 58 75
15
*/


#include<vector>
#include<iostream>
#include<queue>
#include<cstdio>
using namespace std;

int main() {
    int N, M;
    cin >> N;
    cin >> M;
    vector<int> array;
    int i;
    int temp;
    for (i = 0;i < N;i++) {
        cin >> temp;
        array.push_back(temp);

    }
    priority_queue<int, vector<int>, greater<int>> que;//优先输出的较小的数值
    vector<int> tmp_arr;
    vector<int> output;

    int tmp;
    for (i = 0;i < M;i++) {
        tmp = array[i];
        que.push(tmp);
    }
    int sum = 0;
    int small;
    while (sum < N) {
        small = que.top();
        output.push_back(small);
        que.pop();
        sum++;
        if (i < N) {
            if (array[i] > small) {
                tmp = array[i];
                que.push(tmp);
                i++;
            }
            else {
                tmp = array[i];
                tmp_arr.push_back(tmp);
                i++;
            }
        }
        int j;
        if (que.empty()) {
            for (j = 0; j < output.size() - 1; j++) {
                    cout << output[j] << " ";
            }
            cout << output[j] << endl;
            output.clear();//清空
            for (j = 0; j < tmp_arr.size(); j++) {
                que.push(tmp_arr[j]);
            }
            tmp_arr.clear();
        }
    }

    return 0;
}
